
class LevenshteinPos:

    # Any one-time initialization code can go here.  There entire nested question-and-answer
    # dataset is passed as a parameter, in case the initialization requires any of that data.

    def init(self, allQuestions):
        for q in allQuestions:
            allQuestions[q]['levenshteinCoded'] = self.encode(allQuestions[q]['question_words_pos_nostopwords'])
            allQuestions[q]['levenshteinCodedSimple'] = self.encodeSimple(allQuestions[q]['question_words_pos_nostopwords'])
            for r in allQuestions[q]['related']:
                allQuestions[q]['related'][r]['levenshteinCoded'] = self.encode(allQuestions[q]['related'][r]['question_words_pos_nostopwords'])
                allQuestions[q]['related'][r]['levenshteinCodedSimple'] = self.encodeSimple(allQuestions[q]['related'][r]['question_words_pos_nostopwords'])
        return

    # Given a specific question, return a feature vector (one-dimensional array of one
    # or more features.

    def createFeatureVector(self, question, parentQuestion):
        distance = LevenshteinPos.levenshtein(question['levenshteinCoded'], parentQuestion['levenshteinCoded'])
        distanceSimple = LevenshteinPos.levenshtein(question['levenshteinCodedSimple'], parentQuestion['levenshteinCodedSimple'])
        return [distance, distanceSimple]

    # Returns a list of names for the features generated by this module.  Each entry in the
    # list should correspond to a feature in the createFeatureVector() response.

    def getFeatureNames(self):
        return ['levenshtein-pos', 'levenshtein-pos-simple']

    def encode(self, word_pos_list):
        output = ''
        for word_pos in word_pos_list:
            word, pos = word_pos
            output += self.encodePOS(pos)
        return output

    def encodeSimple(self, word_pos_list):
        output = ''
        for word_pos in word_pos_list:
            word, pos = word_pos
            output += self.encodePOSSimple(pos)
        return output

    def encodePOSSimple(self, pos):
        lookup = {
            'VB' : 'V',
            'JJ' : 'J',
            'PR' : 'P',
            'NN' : 'N',
            'RB' : 'R'
        }
        return lookup.get(pos[:2], '')

    def encodePOS(self, pos):
        lookup = {
            'PRP': 'A',
            'VBD': 'B',
            'VBN': 'C',
            'NN': 'D',
            'NNP': 'E',
            'NNS': 'F',
            'CC': 'G',
            'JJ': 'H',
            'VBG': 'I',
            'MD': 'J',
            'VB': 'K',
            'RB': 'L',
            'IN': 'M',
            'VBZ': 'N',
            'VBP': 'O',
            'CD': 'P',
            'DT': 'Q',
            'JJS': 'R',
            'POS': 'S',
            'PRP$': 'T',
            'EX': 'U',
            'FW' : 'V',
            'WRB' : 'W',
            'WP': 'X',
            'NNPS': 'Y',
            'TO': 'Z',
            'JJR': '0',
            'RBR': '1',
            'UH': '2',
            'RP': '3',
            'WDT': '4',
            'SYM': '5',
            'RBS': '6',
            'WP$': '7',
            '$': '8'
        }

        return lookup.get(pos, '')

    @staticmethod
    def levenshtein(s1, s2):
        if len(s1) < len(s2):
            return LevenshteinPos.levenshtein(s2, s1)

        # len(s1) >= len(s2)
        if len(s2) == 0:
            return len(s1)

        previous_row = range(len(s2) + 1)
        for i, c1 in enumerate(s1):
            current_row = [i + 1]
            for j, c2 in enumerate(s2):
                insertions = previous_row[
                                 j + 1] + 1  # j+1 instead of j since previous_row and current_row are one character longer
                deletions = current_row[j] + 1  # than s2
                substitutions = previous_row[j] + (c1 != c2)
                current_row.append(min(insertions, deletions, substitutions))
            previous_row = current_row

        return previous_row[-1]
