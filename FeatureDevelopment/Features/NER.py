import nltk
from nltk import *
from nltk.tag import StanfordNERTagger
import os

from utilities import forEachQuestion


class NER:

    # Any one-time initialization code can go here.  There entire nested question-and-answer
    # dataset is passed as a parameter, in case the initialization requires any of that data.

    def init(self,allQuestions):
        self.nerMachine=StanfordNERTagger('english.all.3class.distsim.crf.ser.gz')
        return

    # Given a specific question, return a feature vector (one-dimensional array of one
    # or more features.
    def createFeatureVector(self, question, parentQuestion):
        # This is just placeholder code - insert code that actually generates a feature vector here
        # for the given question, and then return that feature vector instead of [0].
        question['ner']=self.nerMachine.tag(question['question_words'])
        parentQuestion['ner'] = self.nerMachine.tag(parentQuestion['question_words'])
        # print(question['ner'])
        # print(parentQuestion['ner'])
        qNer=[]
        pNer=[]
        for i in question['ner']:
            for j in parentQuestion['ner']:
                if not i[1]=='O':
                    qNer.append(str.lower(i[0]))
                if not j[1] == 'O':
                    pNer.append(str.lower(j[0]))
        feature = len(list(set(qNer).intersection(pNer)))
        # for i in parentQuestion['ner']:
        #     if not i[1]=='O':
        #         pNer.append(str.lower(i[0]))
        # print(qNer)
        # print(pNer)
        # feature=len(list(set(qNer).intersection(pNer)))
        # print(feature)
        #Calculate named entity overlap
        return [feature]

    # Returns a list of names for the features generated by this module.  Each entry in the
    # list should correspond to a feature in the createFeatureVector() response.

    def getFeatureNames(self):
        return ['NER']